#!/usr/bin/env python3
import argparse, json, os, re, shutil, subprocess, tempfile
from typing import Dict, List, Tuple, Optional

TEMPLATE_MAVEN = """# Generated by auto_convert_repo_to_ado_yaml.py (Java/Maven)
trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
{VARIABLES}# (empty when no variables)

steps:
- checkout: self

- task: Maven@4
  displayName: Build & Test (Maven)
  inputs:
    mavenPomFile: {MAVEN_POM}
    goals: {MAVEN_GOALS}
    options: {MAVEN_OPTIONS}
    publishJUnitResults: true
    testResultsFiles: '**/surefire-reports/TEST-*.xml'
"""

TEMPLATE_GRADLE = """# Generated by auto_convert_repo_to_ado_yaml.py (Java/Gradle)
trigger:
- main

pool:
  vmImage: ubuntu-latest

variables:
{VARIABLES}# (empty when no variables)

steps:
- checkout: self

- task: Gradle@3
  displayName: Build (Gradle)
  inputs:
    gradleWrapperFile: {GRADLE_WRAPPER}
    tasks: {GRADLE_TASKS}
    publishJUnitResults: true
    testResultsFiles: '**/TEST-*.xml'
"""

TEMPLATE_DOTNET = """# Generated by auto_convert_repo_to_ado_yaml.py (.NET)
trigger:
- main

pool:
  vmImage: {DOTNET_IMAGE}

variables:
{VARIABLES}# (empty when no variables)

steps:
- checkout: self

- task: UseDotNet@2
  displayName: Set up .NET SDK
  inputs:
    packageType: 'sdk'
    version: {DOTNET_SDK}

- script: dotnet restore
  displayName: Restore

- script: dotnet build --configuration Release --no-restore
  displayName: Build

- script: dotnet test --configuration Release --no-build --logger "trx;LogFileName=test_results.trx"
  displayName: Test
"""

DECL_PIPE_RE = re.compile(r"pipeline\s*\{", re.I)

def run(cmd: List[str], cwd: Optional[str] = None):
    p = subprocess.Popen(cmd, cwd=cwd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    out, err = p.communicate()
    return p.returncode, out, err

def clone_if_url(repo_arg: str):
    if re.match(r"^https?://", repo_arg):
        tmp = tempfile.mkdtemp(prefix="auto-mig-")
        code, out, err = run(["git", "clone", "--depth", "1", "--no-tags", repo_arg, tmp])
        if code != 0:
            raise RuntimeError(f"git clone failed: {err or out}")
        return tmp, True
    if not os.path.isdir(repo_arg):
        raise FileNotFoundError(f"Repo path not found: {repo_arg}")
    return os.path.abspath(repo_arg), False

def list_files(root: str) -> List[str]:
    paths = []
    for d, _, files in os.walk(root):
        for f in files:
            paths.append(os.path.join(d, f))
    return paths

def read_text(path: str) -> str:
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        return f.read()

def find_jenkinsfiles(root: str) -> List[str]:
    files = list_files(root)
    candidates = [p for p in files if os.path.basename(p).lower() in ("jenkinsfile", "jenkinsfile.groovy")]
    candidates.sort(key=lambda p: (p.count(os.sep), len(p)))
    return candidates

def flatten_env_block(jf_text: str) -> Dict[str, str]:
    env: Dict[str, str] = {}
    flat = " ".join(jf_text.splitlines())
    for m in re.finditer(r"environment\s*\{([^}]*)\}", flat, flags=re.I):
        block = m.group(1)
        for kv in re.finditer(r"([A-Za-z_][A-Za-z0-9_]*)\s*=\s*['\"]([^'\"]+)['\"]", block):
            env[kv.group(1)] = kv.group(2)
    return env

def format_variables(env: Dict[str, str]) -> str:
    if not env:
        return ""
    return "".join(f"  - name: {k}\n    value: \"{v.replace('\"','\\\"')}\"\n" for k, v in env.items())

def detect_dotnet_sdk(repo_root: str) -> str:
    gj = os.path.join(repo_root, "global.json")
    if os.path.exists(gj):
        try:
            data = json.loads(read_text(gj))
            v = data.get("sdk", {}).get("version")
            if v:
                return v
        except Exception:
            pass
    return "8.0.x"

def detect_stack(repo_root: str, jenkinsfile_texts: List[str]):
    files = [p.lower() for p in list_files(repo_root)]
    names = [os.path.basename(p) for p in files]
    text = ("\n".join(jenkinsfile_texts)).lower()

    conf = {"maven": 0, "gradle": 0, "dotnet": 0}
    reasons = {k: [] for k in conf}

    if any(os.path.basename(p) == "pom.xml" for p in list_files(repo_root)):
        conf["maven"] += 40; reasons["maven"].append("pom.xml present")
    if re.search(r"\bmvn\b", text):
        conf["maven"] += 30; reasons["maven"].append("mvn commands")
    if "mvnw" in names or "mvnw.cmd" in names:
        conf["maven"] += 20; reasons["maven"].append("mvnw wrapper")

    if any(os.path.basename(p).startswith("build.gradle") for p in list_files(repo_root)):
        conf["gradle"] += 40; reasons["gradle"].append("build.gradle present")
    if "gradlew" in names or "gradlew.bat" in names:
        conf["gradle"] += 20; reasons["gradle"].append("gradle wrapper")
    if re.search(r"\bgradle(w)?\b", text):
        conf["gradle"] += 20; reasons["gradle"].append("gradle commands")

    if any(p.endswith(".sln") or p.endswith(".csproj") for p in files):
        conf["dotnet"] += 50; reasons["dotnet"].append("*.sln/*.csproj present")
    if re.search(r"\bdotnet\s+(restore|build|test|publish)\b", text):
        conf["dotnet"] += 40; reasons["dotnet"].append("dotnet commands")
    if os.path.exists(os.path.join(repo_root, "global.json")):
        conf["dotnet"] += 10; reasons["dotnet"].append("global.json present")

    stack = max(conf, key=lambda k: conf[k])
    confidence = conf[stack]
    if confidence == 0:
        return "unsupported", 0, []
    return stack, confidence, reasons[stack]

def build_yaml_maven(repo_root: str, jf_text: str, env: Dict[str, str]) -> str:
    pom = "pom.xml"
    for p in list_files(repo_root):
        if os.path.basename(p) == "pom.xml":
            pom = os.path.relpath(p, repo_root).replace("\\", "/")
            break
    goals = "clean install"
    m = re.search(r"\bmvn\s+([^\n\"']+)", jf_text, flags=re.I)
    if m:
        goals = m.group(1).strip()
    mapping = {
        "VARIABLES": format_variables(env),
        "MAVEN_POM": pom,
        "MAVEN_GOALS": goals,
        "MAVEN_OPTIONS": '""',
    }
    out = TEMPLATE_MAVEN
    for k, v in mapping.items():
        out = out.replace("{"+k+"}", v)
    return out

def build_yaml_gradle(repo_root: str, jf_text: str, env: Dict[str, str]) -> str:
    wrapper = "gradlew" if os.path.exists(os.path.join(repo_root, "gradlew")) else "gradle"
    tasks = "build"
    m = re.search(r"\bgradle(w)?\s+([^\n\"']+)", jf_text, flags=re.I)
    if m:
        tasks = m.group(2).strip()
    mapping = {
        "VARIABLES": format_variables(env),
        "GRADLE_WRAPPER": wrapper,
        "GRADLE_TASKS": tasks,
    }
    out = TEMPLATE_GRADLE
    for k, v in mapping.items():
        out = out.replace("{"+k+"}", v)
    return out

def build_yaml_dotnet(repo_root: str, jf_text: str, env: Dict[str, str]) -> str:
    sdk = detect_dotnet_sdk(repo_root)
    image = "windows-latest" if re.search(r"\b(bat|powershell)\b", jf_text, flags=re.I) else "ubuntu-latest"
    mapping = {
        "VARIABLES": format_variables(env),
        "DOTNET_SDK": sdk,
        "DOTNET_IMAGE": image,
    }
    out = TEMPLATE_DOTNET
    for k, v in mapping.items():
        out = out.replace("{"+k+"}", v)
    return out

def main():
    ap = argparse.ArgumentParser(description="Auto-detect tech stack and generate Azure Pipelines YAML from Jenkinsfile.")
    ap.add_argument("--repo", required=True, help="Local repo path or Git URL (public)")
    ap.add_argument("--out-dir", default=None, help="Optional output directory; default is repo root")
    args = ap.parse_args()

    # Clone or use local path
    if re.match(r"^https?://", args.repo):
        import tempfile
        tmp = tempfile.mkdtemp(prefix="auto-mig-")
        code, out, err = run(["git", "clone", "--depth", "1", "--no-tags", args.repo, tmp])
        if code != 0:
            raise RuntimeError(f"git clone failed: {err or out}")
        repo_path, is_temp = tmp, True
    else:
        repo_path, is_temp = os.path.abspath(args.repo), False
        if not os.path.isdir(repo_path):
            raise FileNotFoundError(f"Repo path not found: {repo_path}")

    try:
        files = list_files(repo_path)
        jfs = [p for p in files if os.path.basename(p).lower() in ("jenkinsfile", "jenkinsfile.groovy")]
        jfs.sort(key=lambda p: (p.count(os.sep), len(p)))
        if not jfs:
            raise FileNotFoundError("No Jenkinsfile found in repo")
        jf_path = jfs[0]
        jf_text = read_text(jf_path)
        if not DECL_PIPE_RE.search(jf_text):
            raise ValueError("Only Declarative Jenkins pipelines supported (no 'pipeline { ... }' found)")

        env = flatten_env_block(jf_text)
        stack, confidence, reasons = detect_stack(repo_path, [jf_text])

        if stack == "unsupported":
            raise ValueError("Unsupported or unknown stack (v1 supports Maven/Gradle/.NET).")

        if stack == "maven":
            yaml_text = build_yaml_maven(repo_path, jf_text, env)
        elif stack == "gradle":
            yaml_text = build_yaml_gradle(repo_path, jf_text, env)
        else:
            yaml_text = build_yaml_dotnet(repo_path, jf_text, env)

        out_dir = args.out_dir or repo_path
        os.makedirs(out_dir, exist_ok=True)
        out_path = os.path.join(out_dir, "azure-pipelines.yml")
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(yaml_text)

        print(json.dumps({
            "repo": args.repo,
            "jenkinsfile": os.path.relpath(jf_path, repo_path),
            "stack": stack,
            "confidence": confidence,
            "reasons": reasons,
            "output": os.path.abspath(out_path),
        }, indent=2))

    finally:
        if is_temp:
            shutil.rmtree(repo_path, ignore_errors=True)

if __name__ == "__main__":
    main()
